<!DOCTYPE html>
<html lang="en">
<head>
    
    
    <%- include("partials/meta") %>
   
    <title>Inicio</title>
</head>
<body>
    <%- include("partials/header") %>
    
    <section id="pantalla-dividida">
        <%- include("partials/izquierda") %>

        
        <div class="derecha">
            <div class="borde">
            <center><h3>Árboles Red Black y principales operaciones</h3></center> <!--Ponen el titulo del tema y abajo el contenido-->
            <br>
            <p>Los árboles rojinegros son una variante de los árboles binarios de búsqueda que se utilizan para mantener el árbol equilibrado y garantizar un rendimiento óptimo en las operaciones de inserción, eliminación y búsqueda. Un árbol rojinegro cumple con las siguientes propiedades:</p>
            <li>Todos los nodos son rojos o negros.</li>
            <li>La raíz del árbol es siempre negra.</li>
            <li>Todos los hijos null de un nodo son siempre negros.</li>
            <li>Si un nodo es rojo, sus hijos deben ser negros.</li>
            <li>En cualquier camino desde un nodo hasta un nodo null, el número de nodos negros debe ser el mismo.</li>

            <p>Para mantener estas propiedades y garantizar que el árbol siempre esté equilibrado, se realizan rotaciones y se cambian los colores de los nodos cuando se insertan o eliminan elementos del árbol. Esto permite que el árbol siempre tenga una altura logarítmica en función del número de nodos, lo que significa que las operaciones de inserción, eliminación y búsqueda tienen una complejidad de O(log n).</p>

            <div class="panel-body">
                <pre>
                    <ol>
                        <li>#include &lt;iostream&gt;</li>
<li></li>
<li>const bool RED = true;</li>
<li>const bool BLACK = false;</li>
<li></li>
<li>struct Node {</li>
<li>  int data;</li>
<li>  bool color;</li>
<li>  Node *left, *right, *parent;</li>
<li></li>
<li>  Node(int data) : data(data) {</li>
<li>    color = RED;</li>
<li>    left = right = parent = nullptr;</li>
<li>  }</li>
<li>};</li>
<li></li>
<li>class RedBlackTree {</li>
<li>private:</li>
<li>  Node *root;</li>
<li>  Node *nil;</li>
<li></li>
<li>public:</li>
<li>  RedBlackTree() {</li>
<li>    nil = new Node(0);</li>
<li>    nil-&gt;color = BLACK;</li>
<li>    nil-&gt;left = nil-&gt;right = nil-&gt;parent = nil;</li>
<li>    root = nil;</li>
<li>  }</li>
<li></li>
<li>  void LeftRotate(Node *&, Node *&);</li>
<li>  void RightRotate(Node *&, Node *&);</li>
<li>  void InsertFixup(Node *&, Node *&);</li>
<li>  void Insert(Node *&, Node *&, int);</li>
<li>  void Inorder(Node *&);</li>
<li>  void LevelOrder(Node *&);</li>
<li>};</li>
                    </ol>
                </pre>
            </div>

            <h5>Inserción:</h5>
            <li>Creamos un nuevo nodo con la clave que queremos insertar y lo insertamos en el árbol como lo haríamos en un árbol binario de búsqueda.</li>
            <li>Luego, corregimos cualquier violación de las propiedades del árbol rojinegro que pueda haberse producido durante la inserción. Esto implica realizar rotaciones y cambiar los colores de los nodos según sea necesario.</li>
            <p></p>

            <h5>Eliminación:</h5>
            <li>Buscamos el nodo que queremos eliminar en el árbol. Si no lo encontramos, no hay nada que eliminar.</li>
            <li>Eliminamos el nodo del árbol como lo haríamos en un árbol binario de búsqueda.</li>
            <li>Corregimos cualquier violación de las propiedades del árbol rojinegro que pueda haberse producido durante la eliminación. Esto implica realizar rotaciones y cambiar los colores de los nodos según sea necesario.</li>
            <p></p>
            <h5>Búsqueda:</h5>
            <li>Comenzamos en la raíz del árbol y comparamos la clave que estamos buscando con la clave del nodo actual.</li>
            <li>Si son iguales, hemos encontrado el nodo y devolvemos su dirección.</li>
            <li>Si la clave que estamos buscando es menor que la clave del nodo actual, buscamos en el hijo izquierdo del nodo. Si es mayor, buscamos en el hijo derecho.</li>
            <li>Si llegamos a un nodo null sin encontrar la clave, significa que la clave no se encuentra en el árbol y devolvemos null.</li>

            
            <p>Link de apoyo</p>
            <li><a href="https://www.geeksforgeeks.org/introduction-to-red-black-tree/">Introducción al arbol rojinegro</a></li>
            <li><a href="https://www.programiz.com/dsa/red-black-tree">Árbol rojinegro</a></li>

            <br />
            <div class="siguiente">
              <p>Siguiente tema:</p>
              <a href="/STeIT">Sement Tree e Interval Tree >></a>
            </div>
        </div>
    </div>
    </section>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
</body>
</html>